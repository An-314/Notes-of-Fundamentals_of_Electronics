#import "@local/mytemplate:1.0.0": *
#import "@preview/physica:0.9.2": *

= 门电路

数字电路的元件：

#grid(
  columns: (1fr, 1fr, 1fr),
  [*结构*
- 分层设计
- 每个层次的复杂性有限
- 可重复使用的构件],
  [
*接口*
- 系统工程的关键要素
- 隔离技术，允许演进
- 主要抽象机制
  ],
  [
    *什么是好的系统设计？*
- 最小的机制，最大的功能
- 在各种环境下都可靠
- 适应未来的技术改进

  ]
)

*获得高、低电平的基本原理*：

工作电路在直流状态。

#figure(
  image("pic/2024-04-02-08-47-47.png", width: 80%),
  caption: [
    获得高、低电平的基本原理
  ],
)

电阻：不能太大、不能太小

== 二极管门电路

=== 二极管的开关特性

#figure(
  image("pic/2024-04-02-08-56-53.png", width: 30%),
  caption: [
    二极管的开关特性
  ],
)

- 高电平：$V_"IH" = V_"CC"$，此时二极管截止，$V_"O" = V_"CC"$
- 低电平：$V_"IL" = 0$，此时二极管导通，$V_"O" = 0.7$

=== 二极管门电路

#figure(
  image("pic/2024-04-02-09-16-13.png", width: 30%),
  caption: [
    二极管或门
  ],
)

#figure(
  image("pic/2024-04-02-09-17-00.png", width: 10%),
  caption: [
    二极管与门
  ],
)

*二极管构成的门电路的缺点*
- 电平有偏移
- 带负载能力差
- 只用于IC内部电路

== CMOS门电路（Complementary）


#figure(
  image("pic/2024-04-02-09-04-33.png", width: 80%),
  caption: [
    NFET
  ],
)

#figure(
  image("pic/2024-04-02-09-05-11.png", width: 80%),
  caption: [
    PFET
  ],
)

=== CMOS反相器的工作原理

#figure(
  image("pic/2024-04-02-09-10-30.png", width: 80%),
  caption: [
    CMOS反相器
  ],
)

MOS管工作在*可变电阻区*——由于与截至的MOS分压可以保证其电压在可变电阻区。

#figure(
  image("pic/2024-04-02-09-21-05.png", width: 40%),
  caption: [
    输入输出曲线
  ],
)

该输入输出遵循了数字电路元件的原则：其输出是稳定的。

CMOS可以理解为两个变化相反的可变电阻串联，从而起到开关的作用。

=== 电压、电流传输特性

#grid(
  columns: (1fr, 1fr),
  [#figure(
    image("pic/2024-04-02-09-24-30.png", width: 80%),
    caption: [
      电压传输特性
    ],
  )],
  [
    - AB段：$V_I < V_"GS(TH)N"$，$T_1$导通、$T_2$截止；$V_O = V_(O H) =  V_"DD"$

    - CD段：$V_I > V_"DD" - |V_"GS(TH)N"|$，$T_1$截止、$T_2$导通；$V_O = V_(O L) =  0$
    - BC段：$V_"GS(TH)N" < V_I < V_"DD" - |V_"GS(TH)N"$，$T_1$、$T_2$同时导通；如若$T_1,T_2$参数完全对称，则$V_I = 1/2 V_"DD"$时，$V_O = 1/2 V_"DD"$
  ],
  [
    #figure(
      image("pic/2024-04-02-09-24-58.png", width: 80%),
      caption: [
        电流传输特性
      ],
    )
  ],
  [
    这也意味着在电位（逻辑）转换的时候，电路的功率消耗会变大；保持稳定时，功率消耗较小。
  ]
)

=== 输入噪声容限

在$V_I$偏离$V_(I H)$和$V_(I L)$的一定范围内，$V_O$基本不变；在输出变化允许范围内。允许输入的变化范围称为*输入噪声容限*。

#figure(
  image("pic/2024-04-11-01-11-52.png", width: 80%),
  caption: [
    输入噪声容限
  ],
)

可以看出它对输入的变化是有容忍度的，并且输出依旧保持很好的稳定性。可以接受较宽泛的输入值，但给出比较精确稳定的输出值。

#figure(
  image("pic/2024-04-11-01-13-20.png", width: 80%),
  caption: [
    $V_"DD"$对噪声容限的影响
  ],
)


可以通过提高$V_"DD"$来提高噪声容限。

=== CMOS 反相器的静态输入/出特性

==== 输入特性

#figure(
  image("pic/2024-04-02-09-28-27.png", width: 80%),
  caption: [
    输入特性
  ],
)

正常工作时候不形成电流，超过$V_"DD" + 0.7V$或者低于$-0.7V$时，会形成电流。

输入电流特性是保护电路所给的。如果没有保护电路*CMOS本身是没有电流的*。

==== 输出特性

#figure(
  image("pic/2024-04-02-09-34-13.png", width: 80%),
  caption: [
    输出特性
  ],
)

#figure(
  image("pic/2024-04-09-08-08-51.png", width: 80%),
  caption: [
    输出特性
  ],
)

负载电流和负载电阻不能同向变化。特性图的斜率是MOS管的导通电阻。高电平越高，内阻越小（这是MOS管可变电阻区的特性）。

==== 扇出系数（Fan-out）——带负载能力

负载越高，$C$越大。可能会导致原本的信号变成交流噪声。

=== CMOS反相器的动态特性

==== 传输延迟时间

1. 原因：$C_I$与$C_L$充放电，由于$R_"ON"$比较大，充电时间比较长。
2. $t_"PHL"$和$t_"PLH"$受到$C_L$与$V_"DD"$的影响。

前级提供R，后级提供C。
$
R = rho l/A\
C = epsilon A/d\
V(t) = V(oo) + (V(0) - V(oo)) e^(-t/(R C))
$
从而能够得到：
$
t &= R C ln((V(0) - V(oo))/(V(t) - V(oo)))\
&= R C ln((V(oo) - V_"OL")/ (V(oo) - V(t)))\
&= R C ln((V_"DD" - V(0))/ (V_"DD" - V_"TH"))\
&approx R C ln 2
$
#newpara()

TPD（propagation delay time）：是从输入信号发生有效值切换后，输出信号发生有效值切换的时间间隔。

#figure(
  image("pic/2024-04-11-01-20-29.png", width: 60%),
  caption: [
    PD
  ],
)

TCD（contamination delay time）：是从输入信号开始有效值切换后，输出信号开始发生有效值切换的时间间隔。#footnote[一般而言，拿到的器件，TPD要比标准值小，TCD要比标准值大。]

#figure(
  image("pic/2024-04-11-01-23-02.png", width: 80%),
  caption: [
    CD
  ],
)

#figure(
  image("pic/2024-04-11-01-24-50.png", width: 80%),
  caption: [
    传输延迟时间
  ],
)

#figure(
  image("pic/2024-04-11-01-30-31.png", width: 80%),
)

二者数量级相同，但是TPD要比TCD大。

==== 交流噪声容限

如果输入信号的持续的时间很短，不足以充满$C_L$，那么输出信号的变化就会很小。

当输入信号为窄脉冲，且接近于$t_"pd"$时，输出变化跟不上，变化很小，因此交流噪声容限远大于直流噪声容限。

#grid(
  columns: (1fr, 1fr),
  [
    #figure(
      image("pic/2024-04-09-08-34-39.png", width: 80%),
      caption: [
        正脉冲噪声容限
      ],
    )
  ],

  [
    #figure(
      image("pic/pic/2024-04-09-08-09-19.png.png", width: 80%),
      caption: [
        负脉冲噪声容限
      ],
    )
  ]
)

==== 扇出系数（Fan-out）（带负载能力（动态） ）

=== 总功耗

总功耗=静态功耗$P_S$+动态功耗$P_D$

1.静态功耗

静态功耗极小，与动态功耗相比，可以忽略

2.动态功耗

- 导通功耗
  
#figure(
  image("pic/2024-04-11-01-34-19.png", width: 40%),
  caption: [
    动态功耗——导通功耗
  ],
)

- 负载功耗#footnote[功耗的原因也是现在技术都选择使得$V_"DD"$减小，而不是考虑前面的原因增大。]


#figure(
  image("pic/2024-04-11-01-35-18.png", width: 60%),
  caption: [
    动态功耗——负载功耗
  ],
)

负载电容充放电功耗$P_C$
- 当$V_I arrow.t$，$C_L$经$T_2$放电，有
  $
  i_N = C_L dd(v_O)/dd(t) = - C_L dd((V_"DD" - v_O))/dd(t)
  $
- 当$V_I arrow.b$，$V_"DD"$经$T_1$充电，有
  $
  i_P = C_L dd(v_O)/dd(t)
  $
得到平均功率
  $
  P_C = 1/T integral_0^(T/2) i_N v_O dd(t) + 1/T integral_(T/2)^T i_P (V_"DD" - v_O) dd(t) = C_L V_"DD"^2 f
  $

- 总功耗
  $
  P("总功耗") = P_D("动态功耗") + P_S("静态功耗")\
  P_D = P_C("负载功耗") + P_T("导通功耗")\
  P_T = C_(P D) V_"DD"^2 f\
  P_C = C_L V_"DD"^2 f
  $

== 其他类型的CMOS门电路

=== 其他逻辑功能的CMOS门电路

#figure(
  image("pic/2024-04-09-08-45-59.png", width: 80%),
  caption: [
    由CMOS出发——实现其他门电路
  ],
)

由CMOS出发：核心就是改变*上拉和下拉部分*。

#figure(
  image("pic/2024-04-09-09-09-54.png", width: 80%),
  caption: [
    由CMOS出发——实现其他门电路
  ],
)

#grid(
  columns: (1fr, 1fr),
  [
    #figure(
      image("pic/2024-04-09-08-57-08.png", width: 80%),
      caption: [
        与非门
      ],
    )
  ],

  [
    #figure(
      image("pic/2024-04-09-08-57-58.png", width: 80%),
      caption: [
        或非门
      ],
    )
  ]
)

==== 带缓冲极的CMOS门

===== 与非门

#figure(
  image("pic/2024-04-09-09-01-19.png", width: 40%),
  caption: [
    与非门
  ],
)

存在的缺点：
- 输出的高电平和低电平与CMOS反相器不同：高电平更高，低电平更高

===== 解决方法

缓冲极：在输出端加一个缓冲极，使得输出电压更稳定。

#figure(
  image("pic/2024-04-09-09-06-30.png", width: 80%),
  caption: [
    带缓冲极的门电路
  ],
)

*安全问题：门电路不能直接用线并联，需要用门电路相连。*否则造成短路。

#figure(
  image("pic/2024-04-09-09-11-26.png", width: 80%),
  caption: [
    错误连接方法
  ],
)

=== 漏极开路的门电路（OD门）

对于两个不同$V_"DD"$的电路，想让他们嫁接在一起，可以通过OD门来实现。

#figure(
  image("pic/2024-04-09-09-21-35.png", width: 30%),
  caption: [
    OD门
  ],
)

需要自己选择$V_"DD"$和$R_L$（上拉电原和电阻）。

=== 三态输出门

总线结构：多个设备共享一个总线，通过输出门来选择。在这里如果一个模块不工作，就可以用总线将其完全隔离。

#figure(
  image("pic/2024-04-09-09-34-30.png", width: 80%),
  caption: [
    三态输出门
  ],
)

*有物理连接，可以没有电器连接。*用$E N'$进行控制。

#figure(
  image("pic/2024-04-11-08-06-02.png", width: 40%),
  caption: [
    总线结构
  ],
)

= 组合逻辑电路

== 组合逻辑电路的特点

1. 从功能上：任意时刻的输出仅取决于该时刻的输入
2. 从电路结构上：不含记忆（存储）元件

相当于是对逻辑式的直接物理实现。

== 逻辑功能的描述

#figure(
  image("pic/2024-04-11-08-09-57.png", width: 40%),
  caption: [
    逻辑功能的描述
  ],
)

$
bold(Y) = f(bold(A))
$

== 组合逻辑电路的设计方法
1. 逻辑抽象
  - 分析因果关系，确定输入/输出变量
  - 定义逻辑状态的含意（赋值）
  - 列出真值表
2. 写出函数式
3. 选定器件类型
4. 根据所选器件：对逻辑式化简（用门）变换（用MSI）或进行相应的描述（PLD）
5. 画出逻辑电路图，或下载到PLD
6. 工艺设计

_设计举例：设计一个监视交通信号灯状态的逻辑电路_

#grid(
  columns: (1fr, 1fr),
  [
    #figure(
      three-line-table[
        |R|A|G|Z|
        |--|--|--|--|
        |0|0|0|1|
        |0|0|1|0|
        |0|1|0|0|
        |0|1|1|1|
        |1|0|0|0|
        |1|0|1|1|
        |1|1|0|1|
        |1|1|1|1|
      ],
      caption: [
        真值表
      ],
      kind: table
    )
  ],

  [
    #figure(
      image("pic/2024-04-11-08-27-30.png", width: 50%),
      caption: [
        卡诺图
      ],
    )
    $Z = R'A'G' + R A + R G + A G$
    #figure(
      image("pic/2024-04-11-08-28-31.png", width: 40%),
      caption: [
        逻辑电路
      ],
    )
  ]
)

我们寻求通用性的硬件，而不是对于每一种电路都要重新设计一次。

=== 半加器

=== 全加器：将两个1位二进制数及来自低位的进位相加

真值表：

#figure(
  three-line-table[
    |A|B|CI|S|CO|
    |--|--|--|--|--|
    |0|0|0|0|0|
    |0|0|1|1|0|
    |0|1|0|1|0|
    |0|1|1|1|1|
  ],
  caption: [
    真值表
  ],
  kind: table
)

=== 多位加法器

$
(C I)_i = (C O)_(i-1)\
S_i = A_i plus.circle B_i plus.circle (C I)_i\
(C O)_i = (A_i B_i) + (A_i + B_i) (C I)_i
$

==== 串行进位加法器

- 优点：简单
- 缺点：时间延迟高【$n$个$t_(p d)$】，无效功耗高（在一个加法的时候，另外的全加器只能等待）

==== 超前进位加法器

基本原理：加到第$i$位的进位输入信号是两个加数第$i$位以前各位（$0 tilde i-1$）的函数，可在相加之前就计算出来。

=== 用加法器设计组合电路

基本原理：
- 若能生成函数可以变换成输入变量和输入变量相加
- 若能生成函数可以变换成输入变量和常量相加

_例如：8421码转余3码_
$
Y_3Y_2Y_1Y_0 = D C B A + 0011
$

== 若干常用组合逻辑电路

=== 编码器

编码：将输入的每个高/低电平信号变成一个对应的二进制代码
- 普通编码器
- 优先编码器

==== 普通编码器

特点：任何时刻只允许输入一个需要编码的电平信号。

例：3位二进制普通编码器

#figure(
  three-line-table[
    |$I_0$|$I_1$|$I_2$|$I_3$|$I_4$|$I_5$|$I_6$|$I_7$|$Y_2$|$Y_1$|$Y_0$|
    | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
    |1|0|0|0|0|0|0|0|0|0|0|
    |0|1|0|0|0|0|0|0|0|0|1|
    |0|0|1|0|0|0|0|0|0|1|0|
    |0|0|0|1|0|0|0|0|0|1|1|
    |0|0|0|0|1|0|0|0|1|0|0|
    |0|0|0|0|0|1|0|0|1|0|1|
    |0|0|0|0|0|0|1|0|1|1|0|
    |0|0|0|0|0|0|0|1|1|1|1|
  ],
  caption: [
    真值表
  ],
  kind: table
)

$
Y_2 = I_4 + I_5 + I_6 + I_7\
Y_1 = I_2 + I_3 + I_6 + I_7\
Y_0 = I_1 + I_3 + I_5 + I_7
$

#figure(
  image("pic/2024-04-11-09-12-10.png", width: 40%),
  caption: [
    3位二进制普通编码器
  ],
)

==== 优先编码器
特点：允许同时输入两个以上的电平信号，但只对其中优先权最高的一个进行编码。

例：8线-3线优先编码器（设$I_7$优先权最高…$I_0$优先权最低）

#figure(
  three-line-table[
    |$I_0$|$I_1$|$I_2$|$I_3$|$I_4$|$I_5$|$I_6$|$I_7$|$Y_2$|$Y_1$|$Y_0$|
    | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
    |x|x|x|x|x|x|x|1|1|1|1|
    |x|x|x|x|x|x|1|0|1|1|0|
    |x|x|x|x|x|1|0|0|1|0|1|
    |x|x|x|x|1|0|0|0|1|0|0|
    |x|x|x|1|0|0|0|0|0|1|1|
    |x|x|1|0|0|0|0|0|0|1|0|
    |x|1|0|0|0|0|0|0|0|0|1|
    |1|0|0|0|0|0|0|0|0|0|0|
  ],
  caption: [
    真值表
  ],
  kind: table
)

低电平有效：抗干扰能力强；对于TTL电路，输入端悬空、输出为高电平。

#figure(
  image("pic/2024-04-11-09-22-13.png", width: 80%),
  caption: [
    8线-3线优先编码器
  ],
)

$S'$选通信号：当$S = 0$时候，电路不工作；当$S = 1$时候，电路工作。
$
Y_2' = ((I_4 + I_5 + I_6 + I_7) S)'\
$
#newpara()
$Y_S '$为0时，电路允许工作，无编码输入。
$Y_(E X) '$为0时，电路允许工作，有编码输入。

#figure(
  three-line-table[
    |$Y_S '$|$Y_(E X) '$|状态|
    | -- | -- | -- |
    |1 | 1 | 不工作|
    |1 | 0 | 工作、无编码输入|
    |0 | 1 | 工作、有编码输入|
    |0 | 0 | 不可能出现|
  ],
  caption: [
    附加输出信号的状态及含意   
  ],
  kind: table
)

控制端扩展功能举例：用两片8线-3线优先编码器$=>$16线-4线优先编码器

#figure(
  image("pic/2024-04-11-09-35-51.png", width: 80%),
  caption: [
    16线-4线优先编码器
  ],
)

=== 译码器

译码：将每个输入的二进制代码译成对应的输出高、低电平信号。

常用的有：二进制译码器，二-十进制译码器，显示译码器等。

==== 二进制译码器

例如：3线-8线二进制译码器

#figure(
  three-line-table[
    |$I_0$|$I_1$|$I_2$|$Y_7$|$Y_6$|$Y_5$|$Y_4$|$Y_3$|$Y_2$|$Y_1$|$Y_0$|
    | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
    |0|0|0|1|0|0|0|0|0|0|0|
    |0|0|1|0|1|0|0|0|0|0|0|
    |0|1|0|0|0|1|0|0|0|0|0|
    |0|1|1|0|0|0|1|0|0|0|0|
    |1|0|0|0|0|0|0|1|0|0|0|
    |1|0|1|0|0|0|0|0|1|0|0|
    |1|1|0|0|0|0|0|0|0|1|0|
    |1|1|1|0|0|0|0|0|0|0|1|
  ],
  caption: [
    3线-8线二进制译码器
  ],
  kind: table
)

#figure(
  image("pic/2024-04-16-08-12-38.png", width: 40%),
  caption: [
    3线-8线二进制译码器
  ],
)

用二极管与门阵列组成的3线-8线译码器

#figure(
  image("pic/2024-04-16-08-14-09.png", width: 80%),
  caption: [
    3线-8线二进制译码器
  ],
)

对于每一个$Y_i$都相当于一个二极管与门，恰好对应相应的输入。
$
Y_0 = A_2' A_1' A_0' = m_0\
Y_1 = A_2' A_1' A_0 = m_1\
...\
Y_7 = A_2 A_1 A_0 = m_7
$

利用门电路实现：

#figure(
  image("pic/2024-04-16-08-19-39.png", width: 60%),
  caption: [
    3线-8线二进制译码器 74HC138
  ],
)

加上$S$的扩展，现在真值表变成了：

#figure(
  three-line-table[
    |$S$|$S_2'+S_3'$|$I_0$|$I_1$|$I_2$|$Y_7$|$Y_6$|$Y_5$|$Y_4$|$Y_3$|$Y_2$|$Y_1$|$Y_0$|
    | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
    |0|x|x|x|x|1|1|1|1|1|1|1|1|
    |x|1|x|x|x|1|1|1|1|1|1|1|1|
    |1|0|0|0|0|0|1|1|1|1|1|1|1|
    |1|0|0|0|1|1|0|1|1|1|1|1|1|
    |1|0|0|1|0|1|1|0|1|1|1|1|1|
    |1|0|0|1|1|1|1|1|0|1|1|1|1|
    |1|0|1|0|0|1|1|1|1|0|1|1|1|
    |1|0|1|0|1|1|1|1|1|1|0|1|1|
    |1|0|1|1|0|1|1|1|1|1|1|0|1|
    |1|0|1|1|1|1|1|1|1|1|1|1|0|
  ],
  caption: [
    3线-8线二进制译码器
  ],
  kind: table
)

利用附加控制端进行扩展：用74HC138（3线—8线译码器）$=>$4线—16线译码器

#figure(
  image("pic/2024-04-16-08-24-12.png", width: 80%),
  caption: [
    4线—16线译码器
  ],
)

#figure(
  image("pic/2024-04-16-08-29-27.png", width: 80%),
  caption: [
    利用译码器实现逻辑电路
  ],
)

==== 二—十进制译码器

将输入BCD码的10个代码译成10个高、低电平的输出信号BCD码以外的伪码，输出均无低电平信号产生。

=== 显示译码器

==== 七段字符显示器

#figure(
  image("pic/2024-04-16-08-35-16.png", width: 80%),
  caption: [
    七段字符显示器
  ],
)

例如：BCD七段字符显示译码器 （代码转换器） 7448

#figure(
  image("pic/2024-04-16-08-37-18.png", width: 80%),
  caption: [
    7448
  ],
)

全灯测试$L T'$：使所有灯亮起，用于测试。

灭零输入$R B O'/ R B I'$：使所有灯熄灭。

#figure(
  image("pic/2024-04-16-08-40-05.png", width: 80%),
  caption: [
    7448
  ],
)

=== 数据选择器

==== 工作原理

有点类似于多路开关，可以选择不同的输入。

#figure(
  image("pic/2024-04-16-08-45-20.png", width: 80%),
  caption: [
    数据选择器
  ],
)

四位输入的可以用三个二位输入的选择器扩展实现。

#figure(
  image("pic/2024-04-16-08-58-43.png", width: 80%),
  caption: [
    双四选一数据选择器
  ],
)


可以用八选一数据选择器实现任何三位的逻辑表达式，只需要对$D_i$选择$0$或$1$；进一步地，如果$D_i$选择$0,A_3(')$，这样可以实现任何四位的逻辑表达式。

具有$n$位地址输入的数据选择器，至少可产生输入变量不大于$n+1$的组合函数。

#figure(
  image("pic/2024-04-16-09-07-18.png", width: 80%),
  caption: [
    例如红绿灯控制
  ],
)

=== 数值比较器

用来比较两个二进制数的大小，输出比较结果。

== 组合逻辑电路中的竞争-冒险现象

=== 容差性

Output guaranteed to be valid when all inputs have been valid for at least tPD, and, outputs may become invalid no earlier than tCD after an input changes.

#figure(
  image("pic/2024-04-16-09-15-54.png", width: 40%),
  caption: [
    容差性
  ],
)

即使输出从0->0，都会有一段时间的不确定段。

但由于A一直是高电平，这使得输出一直都是低电平，中间的不确定段不会影响输出，全部都是低电平。

LENIENT Combinational Device:

Output guaranteed to be valid when any combination of inputs sufficientto determine output value has been valid for at least tPD.

Tolerates transitions -- and invalid levels -- on irrelevant inputs!

如果有值可以明确锁定输出，这时候输出就不会有不确定段。

例如与非门：

#grid(
  columns: (1fr, 1fr),
  [
    #figure(
    three-line-table[
      |A|B|Y|
      |--|--|--|
      |0|0|1|
      |0|1|1|
      |1|0|1|
      |1|1|0|
    ],
    caption: [
      与非门
    ],
    kind: table
  )
  ],

  [
  #figure(
    three-line-table[
      |A|B|Y|
      |--|--|--|
      |0|0|1|
      |x|1|1|
      |1|x|1|
    ],
    caption: [
      与非门
    ],
    kind: table
  )
  ]
)

=== 竞争-冒险现象及成因

输入同时变化——多个变量不同时变化引发的竞争冒险

卡诺图相切——单个变量引发的竞争冒险；可以使用再加入冗余项的方式来缓解这样的竞争冒险。

== 可编程逻辑器件（PLD, Programmable Logic Device）

数字集成电路从功能上有分为：通用型、专用型两大类

- General ICs——通用型
- Application-Specific ICs——专用型
  
PLD的特点：是一种按通用器件来生产，但逻辑功能是由用户通过对器件编程来设定的。

EDA：电⼦产品从设计、仿真调试、硬件实现全过程⾃动化。

从CAD到EDA
- CAD Computer Aided Design(Draw)
- CAE Computer Aided Engineer
- EDA Electronic Design Automation

EDA的技术特征
- 以超⼤规模IC为基础
- 以⾼性能计算机及软件为平台
- 多学科综合
- 实现电⼦产品从设计到⽣产全过程⾃动化
- 电路软件化－软件即是电路:⽤计算机程序描述电路
- 电路的描述形式 HDL Hardware Description Language

#pagebreak()

= 半导体存储电路

#figure(
  image("pic/2024-04-23-08-23-13.png", width: 80%),
  caption: [
    时序电路
  ],
)

上面的组合电路是没有记忆功能的：不存在状态，所有的输出仅仅取决于输入。

计算机系统的存储结构：存储器、寄存器、缓存、磁盘等。（冯诺依曼结构）

#figure(
  image("pic/2024-05-06-17-08-28.png", width: 80%),
  caption: [
    计算机系统的存储结构
  ],
)

一些术语：
- 存储器单元 cell ： 用于存储一个 bit 的电路单元
- 字节 Byte = 8bits
- 字 Word = 1 - 8 Bytes
- 1 个字中有 8 - 64 bits
- 1B = 8 bit; iKB = 1024B ; 1MB = 1024 KB ; 1GB = 1024MB
- 容量：表示特定存储器单元或整个存储器系统能够存储多少 bits
- 密度：表示容量的另一术语
- 地址：表示 word 在存储系统中位置

== 概述

一、用于记忆二进制信号
1. 有两个能自行保持的状态
2. 根据输入信号可以置成0或1
二、分类
1. 按触发方式（电平，脉冲，边沿）
2. 按逻辑功能（RS, JK, D, T）

#figure(
  image("pic/2024-04-23-08-44-06.png", width: 80%),
  caption: [
    存储
  ],
)

用两个反相器首尾相连，由于正反馈的作用，可以保持0或者1。

== SR锁存器

=== 电路结构与工作原理

#figure(
  image("pic/2024-04-23-08-59-37.png", width: 80%),
  caption: [
    SR锁存器
  ],
)

#figure(
  three-line-table[
    |$S_D$|$R_D$|$Q$|$Q^*$|
    |--|--|--|--|
    |0|0|0|0|
    |0|0|1|1|
    |1|0|0|1|
    |1|0|1|1|
    |0|1|0|0|
    |0|1|1|0|
    |1|1|0|0|
    |1|1|1|0|
  ],
  caption: [
    SR锁存器的真值表
  ],
  kind: table
)

其中$Q^*$表示$Q$的下一状态。

其中$S_D$是选0端，在给入高电平之后，$Q$就会变成0；$R_D$是选1端，在给入高电平之后，$Q$就会变成1。

$S_D$和$Q_D$的$1$同时消失后，$Q^*$不定。*正常工作下，应遵循$S_D R_D = 0$的约束条件。*

=== 动作特点

在任何时刻，输入都能直接改变输出的状态。

#figure(
  image("pic/2024-05-06-17-50-10.png", width: 40%),
  caption: [
    SR锁存器的动作特点
  ],
)

== 电平触发的触发器

=== SR触发器

==== 电路结构与工作原理

#figure(
  image("pic/2024-05-06-17-57-25.png", width: 80%),
  caption: [
    电平触发的触发器
  ],
)

相当于输入控制门+基本SR锁存器。

在CLK = 0时，退化成两个反相器；在CLK = 1时，退化成SR锁存器。只有触发信号CLK到达时，S和R才能起作用。

仍然存在约束条件：$S$和$R$不能同时为1。

同步与异步：同步是指有一个时钟信号，异步是指没有时钟信号。

==== 动作特点

在CLK=1的全部时间⾥，S和R的变化都将引起输出状态的变化。

#figure(
  image("pic/2024-05-06-18-02-58.png", width: 80%),
  caption: [
    电平触发的触发器的动作特点
  ],
)

在CLK = 1期间， Q和Q'可能随 S、R变化多次翻转。

=== D触发器

除了SR触发器，为了保证S和R不同时为1，可以强行令S和R为相反的值。这样就构成了D触发器。

#figure(
  image("pic/2024-04-23-09-17-35.png", width: 80%),
  caption: [
    D触发器
  ],
)

==== 利用MUX实现D触发器：D Latch

#figure(
  image("pic/2024-05-06-18-09-51.png", width: 80%),
  caption: [
    利用MUX实现D触发器
  ],
)

== 脉冲触发的触发器

为了提高可靠性，要求每个CP周期输出状态只能改变1次。

=== 主从D触发器

借鉴高速路收费站的机械构造，引入主、从触发器。

任何时候只有一个锁存器 "透明"：
- 主锁存器打开时从锁存器关闭
- 主锁存器关闭时从锁存器打开
无通过触发器的组合路径

#figure(
  image("pic/2024-05-06-22-07-43.png", width: 80%),
  caption: [
    Master-Slave Flip Flop (Edge-triggered)
  ],
)

Q 仅在 CLK 的 0 - 1 转换后发生变化，因此触发器似乎是由 CLK 的*上升沿* "触发 "的。

#figure(
  image("pic/2024-05-06-22-08-50.png", width: 80%),
  caption: [
    波形图
  ],
)

=== 主从SR触发器

- CLK=1时，主按S、R的状态翻转，从保持
- CLK下降沿达到时，主保持，从按主的状态翻转

每个CLK周期内，输出状态只能改变一次。

与边沿触发器不同的是，边沿触发只看上升沿时候的输入，而主从触发器看的是整个CLK周期内的输入。

#figure(
  image("pic/2024-05-10-23-23-13.png", width: 80%),
  caption: [
    主从SR触发器
  ],
)

#figure(
  image("pic/2024-05-10-23-23-46.png", width: 40%),
  caption: [
    主从SR触发器的真值表
  ],
  kind: table
)
=== 主从JK触发器

加入反馈

为解除约束，当$J=K=1$时，$Q^* = Q'$

#figure(
  image("pic/2024-05-10-23-30-27.png", width: 80%),
  caption: [
    主从JK触发器
  ],
)

#figure(
  image("pic/2024-05-10-23-33-24.png", width: 80%),
  caption: [
    从主从SR触发器改造成主从JK触发器
  ],
)

- 特性：主触发器打开期间，主触发器的值只能变一次。
- 主从RS触发器关心最后一次变化，而主从JK触发器关心第一次变化。

#figure(
  image("pic/2024-05-10-23-34-32.png", width: 80%),
  caption: [
    主从JK触发器的真值表
  ],
  kind: table
)

#figure(
  image("pic/2024-05-10-23-53-53.png", width: 40%),
  caption: [
    主从JK触发器的波形图
  ],
)

=== 脉冲触发方式的动作特点

1. 分两步动作：
  - 第一步CLK = 1时，“主”接收信号，“从”保持
  - 第二步CKL $arrow.b$到达后，“从”按“主”状态翻转
  输出状态只能改变一次
2. 主从SR，“主”为同步SR，CKL=1的全部时间里输入信号对“主”都起控制作用；但主从 在高电平期间，“主”只可能翻转一次
   
   在CKL=1期间里输入发生变化时，要找出CKL $arrow.b$前$Q$最后的状态，决定$Q^*$。


== 边沿触发的触发器

为了提高可靠性，增强抗干扰能力，希望触发器的次态仅取决于CLK的下降沿（或上升沿）到来时的输入信号状态，与在此前、后输入的状态没有关系。

用CMOS传输门的边沿触发器、维持阻塞触发器、用门电路tpd的边沿触发器

=== 电路结构和工作原理

#figure(
  image("pic/2024-05-11-00-01-02.png", width: 80%),
  caption: [
    ⽤两个电平触发D触发器组成的边沿触发器
  ],
)

#figure(
  image("pic/2024-05-11-00-05-21.png", width: 80%),
  caption: [
    利用CMOS传输门的边沿触发器
  ],
)

#figure(
  image("pic/2024-05-11-00-05-04.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-11-00-10-00.png", width: 20%),
  caption: [
    真值表
  ],
)

#figure(
  image("pic/2024-05-11-00-13-48.png", width: 80%),
  numbering: none
)

这是一个上升沿的触发器。

对时钟的周期有要求，至少要信号传输到所有门电路。

=== 动作特点

- $Q^*$变化发生在CLK的上升沿（或下降沿）
- $Q^*$仅取决于上升沿到达时输入的状态，而与此前、后的状态无关

== 触发器的逻辑功能及其描述方法

#figure(
  image("pic/2024-05-11-00-22-42.png", width: 80%),
  numbering: none
)


=== 触发器按逻辑功能的分类

时钟控制的触发器中由于输入方式不同（单端，双端输入）、次态$Q^*$随输入变化的规则不同。

有限状态机：有限个状态，有限个输入，有限个输出。

==== SR触发器

凡在时钟信号作用下，具有如下功能的触发器称为SR触发器
$
Q^* = S'R'Q + S R'Q' + S R'Q = A'R'Q+S R' = S + R'Q\
S R = 0
$

#figure(
  image("pic/2024-04-25-09-06-51.png", width: 80%),
  caption: [
    状态转换图——SR触发器
  ],
)

#figure(
  image("pic/2024-05-11-00-26-43.png", width: 50%),
  caption: [
    符号与真值表
  ],
)

==== JK触发器

状态方程
$
Q^* = J'Q' + K Q
$

#figure(
  image("pic/2024-05-11-00-30-25.png", width: 80%),
  caption: [
    状态转换图——JK触发器
  ],
)

#figure(
  image("pic/2024-05-11-00-31-37.png", width: 50%),
  caption: [
    符号与真值表
  ],
)

==== T触发器

状态方程
$
Q^* = T'Q + T'Q
$
#figure(
  image("pic/2024-05-11-00-33-08.png", width: 80%),
  caption: [
    状态转换图——T触发器
  ],
)
#figure(
  image("pic/2024-05-11-00-34-33.png", width: 40%),
  caption: [
    符号与真值表
  ],
)

==== D触发器

状态方程
$
Q^* = D
$

#figure(
  image("pic/2024-05-11-00-36-06.png", width: 80%),
  caption: [
    状态转换图——D触发器
  ],
)

#figure(
  image("pic/2024-05-11-00-37-04.png", width: 40%),
  caption: [
    符号与真值表
  ],
)

== 触发器的动态特性

- 建立时间 $t_"SETUP"$
- 保持时间 $t_"HOLD"$
- 传输延迟时间
- 最高时钟频率

#figure(
  image("pic/2024-05-11-20-59-50.png", width: 30%),
  caption: [
    触发器的动态特性
  ],
)

#figure(
  image("pic/2024-05-11-21-26-36.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-11-21-27-14.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-11-21-28-00.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-11-21-28-34.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-11-21-29-13.png", width: 80%),
  numbering: none
)

== 寄存器

1. 用于寄存一组二值代码， N位寄存器由N个触发器组成，可存放一组N位二值代码。
2. 只要求其中每个触发器可置1，置0。

#figure(
  image("pic/2024-05-11-21-02-48.png", width: 80%),
  caption: [
    74HC75
  ],
)

#figure(
  image("pic/2024-05-11-21-04-52.png", width: 80%),
  numbering: none
)



== 存储器

能存储大量二值信息的器件

- 单元数庞大
- 输入/输出引脚数目有限

=== 一般结构形式

#figure(
  image("pic/2024-05-07-08-14-48.png", width: 80%),
  caption: [
    存储器的一般结构形式
  ],
)

=== 分类
1、从存/取功能分：
- 只读存储器（Read-Only-Memory）
  - 掩模ROM
  - 可编程ROM
  - 可擦除可编程EPROM
- 随机读/写（Random-Access-Memory）
  - 静态RAM
  - 动态RAM
2、从工艺分：
- 双极型
- MOS型

== 随机存储器RAM

=== 静态随机存储器（SRAM）

==== 结构与工作原理

#figure(
  image("pic/2024-05-07-08-18-50.png", width: 80%),
  caption: [
    静态随机存储器
  ],
)

采用二维是为了减少译码器走出的线的数量。

对于$n$位地址和$m$位数据，需要$2^n times m$个存储单元。

#figure(
  image("pic/2024-05-07-08-24-36.png", width: 80%),
  caption: [
    静态随机存储器
  ],
)

物理连接已经确定，需要用三态的方式来选择电气连接。

=== SRAM的储存单元

#figure(
  image("pic/2024-05-07-08-28-08.png", width: 70%),
  caption: [
    SRAM的储存单元
  ],
)

$T_1 ~ T_4$为基本存储单元，由两个双极型触发器构成。

$X_i = 1$时，所在行被选中，$T_5, T_6$导通，$Q,Q'$和$B_j,B_j'$相通。

$Y_j = 1$时，所在列被选中，$T_7, T_8$导通，此时第$i$行、第$j$列的存储单元被选中。

当$C S' = 0$时，若$R \/ W' = 1$，则$A_1$导通，$A_2,A_3$截至，$Q -> I \/ O$，此时存储单元被读出。
$R \/ W' = 0$，则$A_1$截至，$A_2,A_3$导通，$I \/ O -> Q$，此时存储单元被写入。

=== 动态随机存储器（DRAM）

动态存储单元是利用电容可以存储电荷的原理。

读写会慢，并且需要刷新电路。

#figure(
  image("pic/2024-05-09-01-21-35.png", width: 80%),
  caption: [
    动态随机存储器
  ],
)

== 只读存储器ROM

利用组合电路来实现存储，所以掉电后数据不会丢失。

=== 掩模ROM

==== 结构

#figure(
  image("pic/2024-05-07-08-41-41.png", width: 80%),
  caption: [
    掩模ROM
  ],
)

#figure(
  image("pic/2024-05-07-08-50-57.png", width: 80%),
  caption: [
    掩模ROM
  ],
)

与译码器的结构相同，组成二极管与门、或门。有元件的地方就是1，没有元件的地方就是0。

对于该电路，我们可以得到数据表为：

#figure(
  three-line-table[
    |$A_1$|$A_0$|$W_3$|$W_2$|$W_1$|$W_0$|
    |--|--|--|--|--|--|
    |0|0|0|1|0|1|
    |0|1|1|0|1|1|
    |1|0|0|1|0|0|
    |1|1|1|1|1|0|
  ],
  caption: [
    掩模ROM的数据表
  ],
  kind: table
)

#figure(
  image("pic/2024-05-07-09-01-19.png", width: 80%),
  caption: [
    ROM的模块示意图
  ],
)

两个概念：
- 存储矩阵的每个交叉点是一个“存储单元”，存储单元中有器件存入“1”，无器件存入“0”
- 存储器的容量：字数 $times$ 位数

掩模ROM的特点：

出厂时已经固定，不能更改，适合大量生产。简单，便宜，非易失性。

#figure(
  image("pic/2024-05-07-09-00-38.png", width: 80%),
  caption: [
    掩模ROM
  ],
)

=== 可编程ROM（PROM）

总体结构与掩模ROM一样，但存储单元不同。

#figure(
  image("pic/2024-05-09-01-24-34.png", width: 80%),
  caption: [
    可编程ROM
  ],
)

=== 可擦除的可编程ROM（EPROM）

总体结构与掩模ROM一样，但存储单元不同。

==== 用紫外线擦除的PROM（UVEPROM）

#figure(
  image("pic/2024-05-07-09-03-30.png", width: 80%),
  caption: [
    叠栅注入MOS管
  ],
)

“写入”：雪崩注入，D-S间加高压（20 - 25V的，发生雪崩击穿同时在$G_c$上加 $25 V, 50 "ms"$宽的正脉冲，吸引高速电子穿过SiO2到达$G_f$，形成注入电荷。

“擦除”：通过照射产 生电子 空穴对，提供泄放通道。紫外线照射20-30分钟（阳光下一周，荧光灯下3年）。

==== 电可擦除的可编程ROM（E$""^2$PROM）

为克服UVEPROM擦除慢，操作不便的缺点。采用FLOTOX(浮栅隧道氧化层 MOS )。

#figure(
  image("pic/2024-05-07-09-12-38.png", width: 80%),
  caption: [
    电可擦除的可编程ROM
  ],
)

#figure(
  image("pic/2024-05-07-09-13-52.png", width: 80%),
  caption: [
    电可擦除的可编程ROM
  ],
)

==== 快闪存储器（Flash Memory）

为提高集成度，省去T2（选通管）改用叠栅MOS管（类似SIMOS管）。

#figure(
  image("pic/2024-05-07-09-14-31.png", width: 80%),
  caption: [
    快闪存储器
  ],
)

=== 用存储器实现组合逻辑函数

===== 基本原理

从ROM的数据表可见：若以地址线为输入变量，则数据线即为一组关于地址变量的逻辑函数。

#figure(
  image("pic/2024-05-09-01-25-53.png", width: 80%),
  caption: [
    用存储器实现组合逻辑函数
  ],
)


===  存储器容量的扩展

==== 位扩展方式

适用于每片RAM,ROM字数够用而位数不够时

接法：将各片的地址线、读写线、片选线并联即可

#figure(
  image("pic/2024-05-07-09-18-23.png", width: 80%),
  caption: [
    位扩展方式
  ],
)

==== 字扩展方式

适用于每片RAM,ROM位数够用而字数不够时

#figure(
  image("pic/2024-05-07-09-21-35.png", width: 80%),
  caption: [
    字扩展方式
  ],
)

#figure(
  image("pic/2024-05-07-09-22-19.png", width: 80%),
  caption: [
    字扩展方式
  ],
)

#pagebreak()

= 时序逻辑电路

== 概述

=== 时序逻辑电路的特点

1. 功能上：任一时刻的输出不仅取决于该时刻的输入，还与电路原来的状态有关。

例：串行加法器，两个多位数从低位到高位逐位相加

#figure(
  image("pic/2024-05-07-09-28-00.png", width: 80%),
  caption: [
    串行加法器
  ],
)

工作时候，每次只有一个加法器工作，有多余的时间和功耗。可以采用存储器来存储中间结果。

=== 时序电路的一般结构形式与功能描述方法

#figure(
  image("pic/2024-05-07-09-29-44.png", width: 80%),
  caption: [
    时序电路的一般结构形式
  ],
)

触发器尽量用边沿触发器，减少竞争冒险。

可以用三个方程组来描述：

- 输出方程

$
Y = F (X , Q)
$

- 驱动方程

$
Y = G (X , Q)
$

- 状态方程

$
Q^* = H (Z , Q)
$

=== 时序电路的分类
1. 同步时序电路与异步时序电路

同步：存储电路中所有触发器的时钟使用统一的clk，状态变化发生在同一时刻
异步：没有统一的clk,触发器状态的变化有先有后

2. Mealy型和Moore型

- Mealy型：$Y = F (X , Q)$
- Moore型：$Y = F (Q)$

== 时序电路的分析方法

=== 同步时序电路的分析方法

分析：找出给定时序电路的逻辑功能

即找出在输入和CLK作用下，电路的次态和输出。

一般步骤：
1. 从给定电路写出存储电路中每个触发器的驱动方程（输入的逻辑式），得到整个电路的驱动方程。
2. 将驱动方程代入触发器的特性方程，得到状态方程。
3. 从给定电路写出输出方程。

例如：

#figure(
  image("pic/2024-05-09-08-15-52.png", width: 80%),
  caption: [
    时序电路的分析方法
  ],
)

这是一个Moore型的时序电路。

==== 状态转换表
#figure(
  image("pic/2024-05-09-08-17-31.png", width: 40%),
  caption: [
    状态转换表
  ],
)

$Y$一定使用现态的$Q$计算的，而不是次态的$Q^*$。

==== 状态转换图

#figure(
  image("pic/2024-05-09-08-20-53.png", width: 80%),
  caption: [
    状态转换图
  ],
)

例如：

#figure(
  image("pic/2024-05-09-08-25-12.png", width: 80%),
  caption: [
    时序电路的分析方法
  ],
)

这是一个Mealy型的时序电路。

#figure(
  image("pic/2024-05-09-08-26-36.png", width: 80%),
  caption: [
    状态转换图
  ],
)

注意Moore型和Mealy型的状态转换图。前者的$Y$标在圈内，后者的$Y$标在边上。

=== 异步时序逻辑电路的分析方法

#figure(
  image("pic/2024-05-09-15-42-00.png", width: 80%),
  caption: [
    异步时序逻辑电路的分析方法
  ],
)

== 计数器

- 用于计数、分频、定时、产生节拍脉冲等
- 分类：按时钟分，同步、异步

按计数过程中数字增减分，加、减和可逆

按计数器中的数字编码分，二进制、二-十进制和循环码…

按计数容量分，十进制，六十进制…

=== 同步计数器

==== 同步二进制计数器

原理：根据二进制加法运算规则
可知：在多位二进制数末位加1，若第i位以下皆为1时，则第i位应翻转。
由此得出规律，若用T触发器构成计数器，则第i位触发器输入端$T_i$的逻辑式应为：
$
T_i = Q_(i-1) Q_(i-2) ... Q_0\
T_0 = 1
$

#figure(
  image("pic/2024-05-09-08-44-58.png", width: 50%),
  caption: [
    同步二进制计数器
  ],
)

#figure(
  image("pic/2024-05-09-16-01-50.png", width: 30%),
  caption: [
    74161
  ],
)

#figure(
  image("pic/2024-05-09-16-03-06.png", width: 80%),
  caption: [
    74161的扩展接口
  ],
  kind: table
)

==== 同步二进制减法计数器

原理：根据二进制减法运算规则可知：在多位二进制数末位减1，若第i位以下皆为0时，则第i位应翻转。

由此得出规律，若用T触发器构成计数器，则第i位触发器输入端$T_i$的逻辑式应为：
$
T_i = Q'_(i-1) Q'_(i-2) ... Q'_0\
T_0 = 1
$

#figure(
  image("pic/2024-05-09-16-13-26.png", width: 80%),
  caption: [
    同步二进制减法计数器
  ],
)

==== 同步加减计数器

===== 单时钟方式

加/减脉冲用同一输入端，由加/减控制线的高低电平决定加/减

器件实例：74LS191（用T触发器）

$
T_i = (U' \/ D)' product_(i=0)^(i-1) Q_i + (U' \/ D) product_(i=0)^(i-1) Q'_i\
T_0 = 1
$

#figure(
  image("pic/2024-05-09-16-21-44.png", width: 80%),
  caption: [
    74LS191
  ],
)

#figure(
  image("pic/2024-05-09-16-16-37.png", width: 80%),
  caption: [
    74LS191扩展接口
  ],
  kind: table
)

===== 双时钟方式

加和减分别用两个时钟输入端

$
C L K_i = C L K_U product_(i=0)^(i-1) Q_i + C L K_D product_(i=0)^(i-1) Q'_i\
C L K_0 = C L K_U + C L K_D
$

#figure(
  image("pic/2024-05-09-16-36-19.png", width: 80%),
  caption: [
    74LS193（采用T'触发器）
  ],
)

==== 同步十进制计数器

===== 加法计数器
基本原理：在四位二进制计数器基础上修改，当计到1001时，则下一个CLK电路状态回到0000。

#figure(
  image("pic/2024-05-09-16-56-16.png", width: 80%),
  caption: [
    十进制加法计数器
  ],
)

$
T_0 = 1\
T_1 = Q_0 Q'_3\
T_2 = Q_0 Q_1\
T_3 = Q_1 Q_2 Q_3 + Q_3 Q_0
$

器件实例：74160

#figure(
  image("pic/2024-05-09-17-01-09.png", width: 80%),
  caption: [
    74160
  ],
)

#figure(
  image("pic/2024-05-09-17-01-42.png", width: 80%),
  caption: [
    74160扩展接口
  ],
  kind: table
)

===== 减法计数器

基本原理：对二进制减法计数器进行修改，在0000时减“1”后跳变为1001，然后按二进制减法计数就行了。

$
T_0 = 1\
T_1 = Q'_0(Q'_3 Q'_2 Q'_1)'\
T_2 = Q'_1Q'_0(Q'_3 Q'_2 Q'_1)'\
T_3 = Q_2 Q_1 Q_0
$

#figure(
  image("pic/2024-05-09-17-25-11.png", width: 80%),
  caption: [
    确保该系统可以自启动
  ],
)

===== 十进制可逆计数器

基本原理一致，电路只用到0000~1001的十个状态

实例模块（器件）
- 单时钟：74190,168
- 双时钟：74192

=== 异步计数器

==== 二进制计数器

===== 异步二进制加法计数器

在末位+1时，从低位到高位逐位进位方式工作。

原则：每1位从“1”变“0”时，向高位发出进位，使高位翻转。

#figure(
  image("pic/2024-05-09-17-28-27.png", width: 70%),
  caption: [
    异步二进制加法计数器
  ],
)

===== 异步二进制减法计数器

在末位-1时，从低位到高位逐位借位方式工作。

原则：每1位从“0”变“1”时，向高位发出进位，使高位翻转。

#figure(
  image("pic/2024-05-09-17-29-21.png", width: 80%),
  caption: [
    异步二进制减法计数器
  ],
)

=== 任意进制计数器的构成方法

用已有的N进制芯片，组成M进制计数器，是常用的方法。

==== N > M

原理：计数循环过程中设法跳过$N-M$个状态。

具体方法：置零法 置数法

#figure(
  image("pic/2024-05-09-17-33-35.png", width: 80%),
  caption: [
    N > M的方法
  ],
)

#figure(
  image("pic/2024-05-09-17-35-10.png", width: 80%),
  caption: [
    将十进制的74160接成六进制计数器
  ],
)

其中$G_1,G_2$的结构是为了将峰展宽，使得$Q_0$能够跳过。

#figure(
  image("pic/2024-05-09-17-38-32.png", width: 80%),
  caption: [
    将十进制的74160接成六进制计数器
  ],
)

==== N < M

===== M=N1×N2

先用前面的方法分别接成N1和N2两个计数器。

N1和N2间的连接有两种方式：
1. 并行进位方式：用同一个CLK，低位片的进位输出作为高位片的计数控制信号（如74160的EP和ET）
2. 串行进位方式：低位片的进位输出作为高位片的CLK，两片始终同时处于计数状态

#figure(
  image("pic/2024-05-10-21-18-59.png", width: 80%),
  caption: [
    用两片74160接成100进制计数器
  ],
)

===== M不可分解

采用整体置零和整体置数法：

先用两片接成 M’> M 的计数器，然后再采用置零或置数的方法。

#figure(
  image("pic/2024-05-10-21-58-50.png", width: 80%),
  caption: [
    用74260接成29进制计数器
  ],
)

=== 计数器应用实例

==== 顺序节拍脉冲发生器

计数器+译码器→顺序节拍脉冲发生器

#figure(
  image("pic/2024-05-11-08-08-42.png", width: 80%),
  caption: [
    顺序节拍脉冲发生器
  ],
)

这是一个巡检电路，可以依次对每个$P_i$进行控制。

将译码器的$S_1$接入CLK，这是为了在CLK=0时候可以规避竞争冒险。
 
==== 序列脉冲发生器

计数器+数据选择器→序列脉冲发生器

#figure(
  image("pic/2024-05-11-08-12-01.png", width: 80%),
  caption: [
    序列脉冲发生器
  ],
)

== 时序电路的设计

#figure(
  image("pic/2024-05-11-08-13-02.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-11-08-19-44.png", width: 80%),
  caption: [
    有限状态机
  ],
)

#figure(
  image("pic/2024-05-11-08-23-15.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-11-08-40-11.png", width: 80%),
  numbering: none
)

次态和输出一致，$S_2,S_3$可以合并。

#figure(
  image("pic/2024-05-11-08-41-33.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-11-08-42-41.png", width: 80%),
  numbering: none
)

对于自启动，可以在设计的时候就解决。

#figure(
  image("pic/2024-05-11-09-07-53.png", width: 80%),
  numbering: none
)

一般情况下Mealy和Moore型都能实现，但是Moore型用的状态更多。

#figure(
  image("pic/2024-05-11-09-08-40.png", width: 80%),
  numbering: none
)

== 单时钟同步电路

单一时钟同步数字电路的速度是不受规模限制的，周期受最慢一级的触发器运算时间限制。

我们将以高度受限的方式使用触发器和寄存器（共享一个时钟输入的触发器组）来构建数字系统：
- 无组合周期
- 所有时钟设备共享一个时钟信号
- 只关心时钟上升沿前组合电路的值
- 周期大于每个组合延迟
- 在噪声逻辑转换停止后更改保存状态

#figure(
  image("pic/2024-05-18-21-40-32.png", width: 40%),
  numbering: none
)

#figure(
  image("pic/2024-05-14-08-13-45.png", width: 80%),
  numbering: none
)

输出时序限制：
- Propagation delay传播延迟：$t_"pcq"$ = 保证输出 Q 稳定（即停止变化）的时钟沿后时间
- Contamination delay：$t_"ccq"$ =  时钟边沿后 Q 可能不稳定（即开始变化）的时间

#figure(
  image("pic/2024-05-18-22-20-56.png", width: 50%),
  numbering: none
)

输入时序限制：
- Setup time：$t_"setup"$ = 时钟沿前的时间数据必须稳定（即不变化）
- Hold time：$t_"hold"$ = 时钟沿后的时间数据必须稳定（即不变化）
- Aperture time：$t_"a "$ = 时钟边缘时间数据必须稳定
$
t_"a" = t_"setup" + t_"hold"
$

#newpara()

设置时间限制：
- 取决于从寄存器 R1 通过组合逻辑到 R2 的最大延迟时间
- 寄存器 R2 的输入必须在时钟边沿之前至少$t_"setup"$保持稳定。

$
T_c ≥ t_"pcq" + t_"pd" + t_"setup"
$

#figure(
  image("pic/2024-05-18-22-26-17.png", width: 80%),
  numbering: none
)

保持时间限制：
- 取决于从寄存器 R1 通过组合逻辑到 R2 的最小延迟时间
- 寄存器 R2 的输入必须在时钟沿后至少保持 $t_"hold"$ 稳定

$
t_"hold" < t_"ccq" + t_"cd"
$

#figure(
  image("pic/2024-05-18-22-29-34.png", width: 80%),
  numbering: none
)

*综上，动态时间要求：*
$
T_c ≥ t_"pcq" + t_"pd" + t_"setup"\
t_"cd" > t_"hold" - t_"ccq"
$

=== 时序电路小结

==== 离散的重要性

Digital Values：
- 问题： 区分表示 "1 "和 "0 "的电压
- 解决方案： 禁区： 避免使用类似的电压表示 "1 "和 "0"

Digital Time:
- 问题："哪个过渡最先发生？
- 解决方案：动态时间要求

==== FSM 的局限性
- 尽管 FSM 具有实用性和灵活性，但仍有一些常见问题是 FSM 无法计算的。例如
  
  _格式良好的括号检查器： 给定任何左右括号编码字符串，如果平衡，则输出 1，否则输出 0。这个装置是否等同于我们列举的一种 FSM？_
问题：需要*任意*多个状态，取决于输入。必须 "计算 "未匹配的后缀。一个 FSM 只能记录无数个不匹配的后缀：对于每一个 FSM，我们都能找到一个它无法检查的字符串。

$s$位状态机的状态数是$2^s$，所以有限状态机是有限的。

=== 图灵机和冯诺依曼、哈弗结构

- 分开存储器和处理器
- 用存储器存储程序和数据
- 用处理器执行程序
- 用指令来控制处理器的操作

== 移位寄存器

=== 寄存器

- 用于寄存一组二值代码，N位寄存器由N个触发器组成，可存放一组N位二值代码。
- 只要求其中每个触发器可置1，置0。

#figure(
  image("pic/2024-05-14-08-37-15.png", width: 80%),
  caption: [
    74HC75
  ],
)

CLK上升沿，将$D_0 tilde D_3$存入，与此前后的$D$状态无关，有异步置零功能。

=== 移位寄存器

串变并的功能：将串行数据转换为并行数据

#figure(
  image("pic/2024-05-18-23-17-46.png", width: 80%),
  caption: [
    移位寄存器
  ],
)

#figure(
  image("pic/2024-05-18-23-21-45.png", width: 80%),
  caption: [
    74LS194A
  ],
)


#figure(
  image("pic/2024-05-18-23-24-14.png", width: 80%),
  caption: [
    控制194的工作状态
  ],
)

#figure(
  image("pic/2024-05-18-23-30-05.png", width: 80%),
  caption: [
    移位寄存器的扩展
  ],
)

== 流水线

- Token：一组输入经处理后产生一组输出
- 延迟 Latency：一个Token从开始到结束所需的时间
- 吞吐量 Throughput：单位时间内产生的Token数量
*流水线*增加吞吐量

*定义*
K 级流水线（"K-流水线"）是一种非循环电路，从输入到输出的每条路径上都有 K 个寄存器。因此，一个组合电路就是一条 0 级流水线。

每一级流水线，也就是每一条 K 级流水线，都有一个寄存器位于其输出端（而非输入端）有一个寄存器。

所有寄存器共用的时钟必须有足够的周期，以覆盖组合路径上的传播 PLUS（输入）寄存器 tPDPLUS（输出）寄存器 tSETUP。

- K-pipeline 的延迟时间是所有寄存器共用时钟周期的 K 倍。
- K-pipeline 的 THROUGHPUT 是时钟的频率。

*优点*：
- 打破长组合路径，提高时钟频率，从而提高总输出功率
*缺点*：
- 可能会增加延迟
- 只有最薄弱的环节才是最好的：最慢的步骤限制了系统的总输出。

*电路交错*
- 我们可以通过复制关键元件并在不同副本之间交替输入，来模拟慢速元件的交错版本。

当 Q 为 1 时，下层路径为组合路径（锁存器打开），但上层路径的输出将被启用到输出寄存器的输入端，为下一个时钟沿做好准备。

#figure(
  image("pic/2024-05-19-01-19-27.png", width: 80%),
  numbering: none
)

利用选择器，可以将两个同样地元件按照不同的时钟信号进行切换，起到交错的作用。这样可以提高整体的THROUGHPUT。

== 可编程逻辑器件（PLD, Programmable Logic Device）

=== PLD的基本特点：
1. 数字集成电路从功能上有分为 通用型、专用型两大类
2. PLD的特点：是一种按通用器件来生产，但逻辑功能是由用户通过对器件编程来设定的

=== PLD的发展和分类
PROM是最早的PLD
1. FPLA 现场可编程逻辑阵列
2. PAL可编程逻辑阵列
3. GAL 通用阵列逻辑
4. EPLD 可擦除的可编程逻辑器件
5. CPLD 复杂的可编程逻辑器件
6. FPGA 现场可编程门阵列

#figure(
  image("pic/2024-05-19-01-35-38.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-36-20.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-36-52.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-37-21.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-38-23.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-38-55.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-39-17.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-39-52.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-40-25.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-41-04.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-41-36.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-42-05.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-42-40.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-45-48.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-19-01-46-26.png", width: 80%),
  numbering: none
)

= 脉冲波形的产生和整形

== 概述

=== 获取矩形脉冲的方法
1. 脉冲波形发生电路
2. 脉冲波形整形电路
=== 描述矩形脉冲特性的主要参数
#figure(
  image("pic/2024-05-19-01-48-55.png", width: 80%),
  caption: [
    描述矩形脉冲特性的主要参数
  ],
)

== 施密特触发器（常用的一类脉冲整形电路）

===  用门电路组成的施密特触发器

考虑下面的电路：
#figure(
  image("pic/2024-05-19-01-48-22.png", width: 80%),
  numbering: none
)

当$V_I = 0$时，$V_O = 0$。

当$V_I arrow.t$至$V_A = V_"TH"$时，进入传输特性的放大区，故$V_"A " arrow.t -> V_"O1" arrow.b -> V_O arrow.t -> V_"A " arrow.t$形成正反馈。使电路迅速跳变到$V_O = V_"OH"$。
$
V_A = V_"TH" = (R_2)/(R_1 + R_2) V_I\
V_I = v_"T+" = (1 + R_2/R_1) V_"TH"\
$

#newpara()

当$V_I = 1$时，$V_O = 1$。

当$V_I arrow.t$至$V_A = V_"TL"$时，进入传输特性的放大区，故$V_"A " arrow.t -> V_"O1" arrow.b -> V_O arrow.t -> V_"A " arrow.t$形成正反馈。使电路迅速跳变到$V_O = V_"OL"$。
$
V_A = V_"TH" = (V_"DD" - V_I) R_1/(R_1 + R_2) + V_I\
V_I = v_"T-" = (1 - R_1/R_2) V_"TL"\
$

#figure(
  image("pic/2024-05-19-02-20-02.png", width: 80%),
  caption: [
    用门电路组成的施密特触发器
  ],
)

=== CMOS IC

#figure(
  image("pic/2024-05-19-02-20-43.png", width: 80%),
  caption: [
    CMOS IC
  ],
)

*施密特触发器的主要特点：*
输入信号在上升和下降过程中，电路状态转换的输入电平不同。电路状态转换时有正反馈过程，使输出波形边沿变陡。

===  施密特触发器的应用

==== 用于波形变换 

#figure(
  image("pic/2024-05-19-02-22-16.png", width: 30%),
  caption: [
    用于波形变换
  ],
)

==== 用于鉴幅

#figure(
  image("pic/2024-05-19-02-22-34.png", width: 30%),
  caption: [
    用于鉴幅
  ],
)

==== 用于脉冲整形

#figure(
  image("pic/2024-05-19-02-23-07.png", width: 30%),
  caption: [
    用于脉冲整形
  ],
)

== 单稳态触发器

特点：
1. 有一个稳态和一个暂稳态。
2. 在外界触发信号作用下，能从稳态→暂稳态，维持一段时间后自动返回稳态。
3. 暂稳态维持的时间长短取决于电路内部参数。

=== 用门电路组成的单稳态触发器

==== 积分型

#figure(
  image("pic/2024-05-21-08-09-24.png", width: 80%),
  caption: [
    积分型单稳态触发器
  ],
)

- 稳态下： $V_I = 0,V_O = 1$,$(V_(O 1) = V_(O H) ),V_A = V_(O H)$；
- $V_I arrow.t$ 后， $V_O = 0$,进入*暂稳态*，$V_(O 1) = 0$，$C$开始放电；
- 当放至$V_A = V_"TH"$后，$V_O = 1$，返回稳态；
- $V_I arrow.b$后，$C$重新充电至$V_(O H)$,恢复初始态。

#figure(
  image("pic/2024-05-21-08-16-41.png", width: 80%),
  numbering: none
)

将一个长的脉冲变成一个短的脉冲。

#figure(
  image("pic/2024-05-21-08-19-02.png", width: 80%),
  caption: [
    性能参数计算
  ],
)

==== 微分型

#figure(
  image("pic/2024-05-21-08-30-34.png", width: 80%),
  caption: [
    微分型单稳态触发器
  ],
)

稳态下：$V_I = 0,V_d = 0, V_(I 2) = V_"DD",V_O = 0, V_(O 1) = V_"DD"$，$C$上无电压。

加触发信号$V_I arrow.t$，$V_d arrow.t -> V_(O 1) arrow.b -> V_(I 2) arrow.b -> V_O arrow.t -> V_d arrow.t$，形成正反馈，$V_O = 1$，进入暂稳态，$C$开始充电。

充电至$V_(I 2) = V_"TH"$时，$V_(I 2)$又引起正反馈，$V_(I 2) arrow.t -> V_O arrow.b -> V_(O 1) arrow.t -> V_(I 2) arrow.t$，$V_O = 0$，电路迅速返回稳态。

#figure(
  image("pic/2024-05-21-08-40-31.png", width: 80%),
  caption: [
    性能参数计算
  ],
)

== 多谐振荡器（自激振荡，不需要外加触发信号）

=== 用施密特触发器构成的多谐振荡器

#figure(
  image("pic/2024-05-21-08-45-47.png", width: 80%),
  numbering: none
)

用二极管来选择电阻进行占空比的调节。

=== 环形振荡器

==== 环形振荡器的基本原理

#figure(
  image("pic/2024-05-21-08-54-57.png", width: 80%),
  numbering: none
)

有时延的负反馈环路，可以产生振荡。

==== 实用的环形振荡器

#figure(
  image("pic/2024-05-21-08-58-01.png", width: 80%),
  numbering: none
)

第一步的图中，由于电容的存在，增加了充放电的时间，周期变成了$12 t_"pd"$。

#figure(
  image("pic/2024-05-21-09-14-52.png", width: 80%),
  numbering: none
)

注意$V_(I 3)$处的跳变。

=== 非对称式多谐振荡器

=== 石英晶体多谐振荡器

#figure(
  image("pic/2024-05-21-09-20-21.png", width: 80%),
  numbering: none
)

== 555定时器

=== 555定时器 （数/模混合IC）

==== 电路结构

- 电压比较器（C1,C2）[运算放大器]
- 触发器
- 输出缓冲器（G3,G4）
- OC输出的三极管（TD）

#figure(
  image("pic/2024-05-23-08-14-11.png", width: 80%),
  caption: [
    555定时器
  ],
)

==== 功能表

注意到中间的结构是SR触发器，反向输入，$C_2$对应$S'$，$C_1$对应$R'$。

#figure(
  three-line-table[
    |$R'_D$|$V_(I 1)$|$V_(I 2)$|$V_O$|$T_D$|
    |----|--|--|--|--|
    |0|x|x|0|导通|
    |1|$>2/3 V_"CC"$|$>1/3 V_"CC"$|0|导通|
    |1|$<2/3 V_"CC"$|$>1/3 V_"CC"$|不变|不变|
    |1|$<21/3 V_"CC"$|$<2/3 V_"CC"$|1|截止|
    |1|$>2/3 V_"CC"$|$<1/3 V_"CC"$|1|截止|
  ],
  numbering: none
)

=== 用555定时器接成施密特触发器

#figure(
  image("pic/2024-05-23-08-25-03.png", width: 60%),
  numbering: none
)

=== 用555实现多谐

#figure(
  image("pic/2024-05-23-08-27-25.png", width: 80%),
  numbering: none
)

$R_1$不能太小，否则管子会烧掉；$R_2$不能太大，否则无法达到高电平。

充电时管子截止，$R=R_1 + R_2$；放电时管子导通，$R=R_2$。

#figure(
  image("pic/2024-05-23-08-33-28.png", width: 80%),
  caption: [
    修改占空比
  ],
)

=== 用555实现单稳态触发器

#figure(
  image("pic/2024-05-23-08-34-12.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-23-08-38-20.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-23-08-40-02.png", width: 80%),
  numbering: none
)

性能参数：暂稳态输出有宽度要求，否则导致$Q$始终为1。

$
t_w = R C ln (V_"CC" - 0)/(V_"CC" - 2/3 V_"CC") = R C ln 3
$

如果宽度过宽，可以用微分电路（$V_I$取一个电容到新输入$V'_I$，在$V_I$与$V_"CC"$接一个电阻）只取一个边沿。

= 集成运算放大电路

复合管

#figure(
  image("pic/2024-05-23-09-26-29.png", width: 80%),
  numbering: none
)


== 多级放大电路

=== 多级放大电路的耦合方式

==== 阻容耦合

#figure(
  image("pic/2024-05-28-08-11-01.png", width: 80%),
  numbering: none
)
利用电容连接信号源与放大电路、放大电路的前后级、放大电路与负载，为阻容耦合。

==== 直接耦合

#figure(
  image("pic/2024-05-28-08-13-12.png", width: 80%),
  numbering: none
)

Q点互相影响。

==== 变压器耦合

#figure(
  image("pic/2024-05-28-08-14-39.png", width: 80%),
  numbering: none
)

低频特性差。

==== 光电耦合

#figure(
  image("pic/2024-05-28-08-16-11.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-28-08-16-48.png", width: 80%),
  numbering: none
)

=== 多级放大电路的动态分析

==== 交流分析

1. 电压放大倍数
   
   $
   dot(A) = product_(i=1)^n dot(A)_i
   $
2. 输入电阻
3. 输出电阻

#figure(
  image("pic/2024-05-28-08-23-17.png", width: 80%),
  numbering: none
)

== 集成运算放大电路简介

=== 集成运放的特点

集成运算放大电路，简称集成运放，是一个高性能的直接耦合多级放大电路。因首先用于信号的运算，故而得名。

- 集成电路中不能制作大电容，故采用直接耦合方式。
- 集成运放相邻元件参数具有很好的一致性，故可构成较理想的差分放大电路和电流源电路。
- 用有源元件替代无源元件，如*用晶体管取代难于制作的大电阻*。
- 用复杂电路实现高性能的放大电路，因为电路的复杂化并不带来工艺的复杂性。
- 采用*复合管*。

=== 集成运放电路的方框图

#figure(
  image("pic/2024-05-28-08-26-50.png", width: 80%),
  caption: [
    集成运放电路的方框图
  ],
)

- 偏置电路：为各级放大电路设置合适的*静态工作点*。采用电流源电路。

- 输入级：前置级，多采用*差分放大电路*。要求$R_i$大，$A_d$大，$A_c$小，输入端耐压高。

- 中间级：主放大级，多采用共射放大电路。要求有足够的放大能力。

- 输出级：功率级，多采用准互补输出级。要求$R_o$小，最大不失真输出电压尽可能大。

=== 集成运放的符号及电压传输特性

高性能：输入电阻很大、输出电阻很小、差模放大倍数很大、共模放大倍数很小、共模抑制比高、温度稳定性好……

==== 符号

#figure(
  image("pic/2024-05-28-08-30-21.png", width: 80%),
  caption: [
    集成运放的符号及电压传输特性
  ],
)

不同型号的集成运放供电电源不同，有的两路电源供电，有的一路电源供电，有的两种情况均可。缺省时认为是$±V_"CC"$（常为±15V）供电。

==== 电压传输特性：输出电压与输入电压的函数关系

#figure(
  image("pic/2024-05-28-08-32-00.png", width: 80%),
  caption: [
    电压传输特性
  ],
)

==== 理想运放及其动态等效电路

理想运放的参数特点：
- 差模输入电阻$r_"id"$为$∞$
- 输出电阻$r_o$为$0$
- 开环差模增益$A_"od"$为$∞$
- 共模抑制比$K_"CMR"$为$∞$
- 频带无限宽
- 温度对参数无影响

#figure(
  image("pic/2024-05-28-08-34-02.png", width: 40%),
  caption: [
    理想运放及其动态等效电路
  ],
)

==== 理想运放的两个工作区

将放大电路的输出量通过一定的方式引回到输入端来影响输入量，称为反馈；若反馈的结果使输出量的变化减小，则称为负反馈，否则称为正反馈。

*集成运放工作在线性区需引入负反馈。*

#figure(
  image("pic/2024-05-28-08-34-59.png", width: 40%),
  caption: [
    理想运放的两个工作区
  ],
)

其中反馈通路是无源网络。

- *线性区*： “虚短” 和“虚断”
  - 由于输出电压为有限值，差模开环放大倍数为无穷大，根据$u_O = A_"od" (u_P- u_N)$可知，$u_P - u_N = 0$，即集成运放的*净输入电压为0*，$u_P= u_N$，称为“虚短路” 。
  - 由于净输入电压为0，且集成运放的*输入电阻为无穷大*，所以两个*输入端的输入电流为0*， $i_P = i_N = 0$；即集成运放的净输入电流为0，称为“虚断路” 。
- *非线性区*
  - 输出电压只有两种可能的值，不是$+U_"OM"$，就是$-U_"OM"$，$±U_"OM"$接近其供电电源$±V_"CC"$。
  - 因为$(u_P - u_N)$总是有限值，而$r_"id"=∞$，故净输入电流为0，即$i_P = i_N = 0$，呈“虚断”

== 差分放大电路

=== 零点漂移现象及其产生的原因

*零点漂移现象*：$Δ u_I=0$，$Δ u_O≠0$的现象。

#figure(
  image("pic/2024-05-28-08-36-42.png", width: 80%),
  numbering: none
)

产生原因：温度变化，直流电源波动，元器件老化。其中晶体管的特性对温度敏感是主要原因，故也称零漂为温漂。

克服温漂的方法：引入直流负反馈，温度补偿。

典型电路：差分放大电路。

=== 差分放大电路的概念

==== 需求

#figure(
  image("pic/2024-05-28-08-41-19.png", width: 80%),
  numbering: none
)

需要一种放大电路，对$u_(I 1)$和$u_(I 2)$共同的部分不放大，仅对它们的差值放大。

==== 基本差分放大电路

#figure(
  image("pic/2024-05-28-08-45-31.png", width: 80%),
  numbering: none
)

利用镜像电路，可以保证两边温漂相同。

1. 电路组成——*对称性*

#figure(
  image("pic/2024-05-28-08-52-28.png", width: 80%),
  numbering: none
)

2. Q点分析

$
I_(B Q 1) = I_(B Q 2) = I_(B Q)\
I_(C Q 1) = I_(C Q 2) = I_(C Q)\
I_(E Q 1) = I_(E Q 2) = I_(E Q)\
U_(C Q 1) = U_(C Q 2) = U_(C Q)\
u_o = U_(C Q 1) - U_(C Q 2) = 0
$
晶体管输入回路方程：
$
V_"EE" = I_(B Q) R_b + U_"BEQ" + 2 I_(E Q) R_e\
$

通常，$R_b$较小，且$I_"BQ"$很小，故
$
I_"EQ" approx (V_"EE" - U_"BEQ")/(2 R_e), I_"BQ" = I_"EQ"/(β + 1)\
U_"CEQ" approx V_"CC" - I_"CQ" R_c + U_"BEQ"
$

3. 抑制共模信号：$R_e$的共模负反馈作用

共模信号：数值相等、极性相同的输入信号，即$u_(I 1) = u_(I 2)$。

共模放大倍数：$A_c = (Δ u_(O c))/(Δ u_(I c))$，参数理想对称时，$A_c = 0$。

#figure(
  image("pic/2024-06-02-23-12-16.png", width: 80%),
  numbering: none
)

4. 放大差模信号

差模信号：数值相等，极性相反的输入信号，即$u_(I 1) = -u_(I 2) = 1/2 u_(I d)$。

$
Delta i_(B 1) = - Delta i_(B 2)\
Delta i_(C 1) = - Delta i_(C 2)\
Delta i_(E 1) = - Delta i_(E 2)\
Delta u_(C 1) = - Delta u_(C 2)\
Delta u_O = 2 Delta u_(C 1)
$

$Delta i_(E 1)=- Delta i_(E 2)$，Re中电流不变，即*$R_e$对差模信号无反馈作用*。

E点电压稳定，在交流等效电路中接地。

#figure(
  image("pic/2024-05-28-09-12-44.png", width: 80%),
  numbering: none
)

差模放大倍数：
$
A_d = - (beta (R_C parallel R_L))/(R_b + r_"be")
$

共模抑制比$K_"CMR"$：综合考察差分放大电路放大差模信号的能力和抑制共模信号的能力。

在实际应用时，信号源需要有“接地”点，以避免干扰；或负载需要有“接地”点，以安全工作。

根据信号源和负载的接地情况，差分放大电路有四种接法：双端输入双端输出、双端输入单端输出、单端输入双端输出、单端输入单端输出。

=== 差分放大电路的四种接法

在实际应用时，信号源需要有“接地”点，以避免干扰；或负载需要有“接地”点，以安全工作。

==== 双端输入单端输出

#figure(
  image("pic/2024-05-30-08-16-35.png", width: 80%),
  numbering: none
)

静态工作点的选择和$R_c$有关，选择电流为$(V_"EE" - U_"CE")/R_C$

#figure(
  image("pic/2024-06-02-23-25-02.png", width: 80%),
  numbering: none
)

==== 单端输入双端输出

#figure(
  image("pic/2024-06-03-00-35-01.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-06-03-00-35-51.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-06-03-00-36-26.png", width: 80%),
  numbering: none
)

=== 差分放大电路的改进

==== 具有恒流源的差分放大电路

$R_e$越大，每一边的漂移越小，共模负反馈越强，单端输出时的$A_c$越小，$K_"CMR"$越大，差分放大电路的性能越好。

但为使静态电流不变，$R_e$越大，$V_"EE"$越大，以至于$R_e$太大就不合理了。

需在低电源条件下，设置合适的$I_"EQ"$，并得到得到趋于无穷大的$R_e$。

采用电流源取代$R_e$就解决了这个问题。

#figure(
  image("pic/2024-06-03-00-46-08.png", width: 80%),
  numbering: none
)

==== 加调零电位器$R_W$

#figure(
  image("pic/2024-06-03-00-46-50.png", width: 80%),
  numbering: none
)

==== 场效应管差分放大电路

#figure(
  image("pic/2024-06-03-00-47-23.png", width: 80%),
  numbering: none
)

== 功率放大电路

=== 概述

==== 功率放大电路研究的问题

1. 性能指标：*输出功率和效率*。若已知$U_"om"$，则可得$P_"om"$。$P_"om" = U_"om"^2/(R_L)$。最大输出功率与电源损耗的平均功率之比为效率$η = P_"om"/P_"V"$。

2. 分析方法：因大信号作用，故应采用图解法。

3. 晶体管的选用：根据极限参数选择晶体管。
   
在功放中，晶体管集电极或发射极电流的最大值接近最大集电极电流$I_"CM"$，管压降的最大值接近c-e反向击穿电压$U_"(BR)CEO"$， 集电极消耗功率的最大值接近集电极最大耗散功率$P_"CM"$。称为工作在*尽限状态*。

==== 对功率放大电路的要求

1. 输出功率尽可能大：即在电源电压一定的情况下，最大不失真输出电压最大。
2. 效率尽可能高：即电路损耗的直流功率尽可能小，静态时功放管的集电极电流近似为0。

==== 晶体管的工作方式
1. 甲类方式：晶体管在信号的整个周期内均处于导通状态
2. 乙类方式：晶体管仅在信号的半个周期处于导通状态
3. 甲乙类方式：晶体管在信号的多半个周期处于导通状态


=== OCL电路（Output Capacitor-Less Circuit）

==== 输出级的要求

互补输出级是直接耦合的功率放大电路。

对输出级的要求：
- 带负载能力强：射极输出形式
- 直流功耗小：静态工作电流小
- 负载电阻上无直流功耗：输入为零时输出为零
- 最大不失真输出电压最大：
  - 双电源供电时$U_"om"$的峰值接近电源电压。
  - 单电源供电$U_"om"$的峰值接近二分之一电源电压。

==== 基本电路

特征：虽$T_1$、$T_2$分别为NPN和PNP型管，但特性理想对称。

#figure(
  image("pic/2024-05-30-08-23-02.png", width: 80%),
  caption: [
    OCL的静态工作点
  ],
)

#figure(
  image("pic/2024-05-30-08-23-51.png", width: 80%),
  caption: [
    OCL的动态电路
  ],
)

==== 交越失真

本质是截止失真

#figure(
  image("pic/2024-05-30-08-25-22.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-05-30-08-28-47.png", width: 80%),
  numbering: none
)

#pagebreak()

= 放大电路中的反馈

== 反馈的基本概念及判断方法

=== 反馈的基本概念

反馈放大电路可用方框图表示。

#figure(
  image("pic/2024-06-03-01-12-45.png", width: 80%),
  caption: [
    反馈放大电路的方框图
  ],
)

放大电路输出量的一部分或全部通过一定的方式引回到输入回路，影响输入，称为反馈。

==== 正反馈和负反馈

从反馈的结果来判断，凡反馈的结果使*输出量*的变化减小的为负反馈，否则为正反馈；或者，凡反馈的结果使*净输入量*减小的为负反馈，否则为正反馈。

==== 支流反馈和交流反馈

直流通路中存在的反馈称为直流反馈，交流通路中存在的反馈称为交流反馈。

#figure(
  image("pic/2024-06-03-01-23-10.png", width: 80%),
  numbering: none
)

==== 局部反馈和级间反馈

只对多级放大电路中某一级起反馈作用的称为局部反馈，将多级放大电路的输出量引回到其输入级的输入回路的称为级间反馈。

#figure(
  image("pic/2024-06-03-01-24-18.png", width: 80%),
  numbering: none
)

=== 交流负的四种组态

==== 电压反馈和电流反馈

描述放大电路和反馈网络在输出端的连接方式，即反馈网络的取样对象。

#figure(
  image("pic/2024-06-03-01-29-33.png", width: 60%),
  numbering: none
)

将输出电压的一部分或全部引回到输入回路来影响净输入量的为*电压反馈*，即
$
dot(X)_0 = dot(U)_0
$
将输出电流的一部分或全部引回到输入回路来影响净输入量的为*电流反馈*，即
$
dot(X)_0 = dot(I)_0
$

==== 串联反馈和并联反馈

描述放大电路和反馈网络在输入端的连接方式，即*输入量、反馈量、净输入量的叠加关系*。

串联负反馈：
$
dot(U)_i = dot(U)_i^' + dot(U)_f
$
并联负反馈：
$
dot(I)_i = dot(I)_i^' + dot(I)_f
$

====  四种反馈组态

#figure(
  image("pic/2024-06-03-01-31-44.png", width: 80%),
  numbering: none
)

在串联负反馈电路中不加恒流源信号，在并联负反馈电路中不加恒压源信号。

选择输出端稳定的作为反馈端，选择输入信号的形式作为输入端。

前端是电压源一定要进行并联反馈，这是因为电流源无法给其进行负反馈。

=== 反馈的判断

==== 有无反馈的判断

“找联系”：找输出回路与输入回路的联系，若有则有反馈，否则无反馈。

#figure(
  image("pic/2024-06-03-01-49-13.png", width: 80%),
  numbering: none
)

==== 直流反馈和交流反馈的判断

“看通路”：即看反馈是存在于直流通路还是交流通路。设以下电路中所有电容对交流信号均可视为短路

#figure(
  image("pic/2024-06-03-01-50-16.png", width: 80%),
  numbering: none
)

==== 正、负反馈（反馈极性）的判断

“看反馈的结果” ，即净输入量是被增大还是被减小。

#figure(
  image("pic/2024-06-03-01-51-14.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-06-03-01-51-44.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-06-03-01-52-13.png", width: 80%),
  numbering: none
)

==== 电压反馈和电流反馈的判断

*令输出电压为0，若反馈量随之为0，则为电压反馈；若反馈量依然存在，则为电流反馈。*

#figure(
  image("pic/2024-06-03-01-53-07.png", width: 80%),
  numbering: none
)

==== 串联反馈和并联反馈的判别

在输入端，输入量、反馈量和净输入量以电压的方式叠加，为串联反馈；以电流的方式叠加，为并联反馈。

#figure(
  image("pic/2024-06-03-01-53-50.png", width: 80%),
  numbering: none
)

== 负反馈放大电路的方框图及一般表达式

=== 负反馈放大电路的方框图

#figure(
  image("pic/2024-06-03-01-55-59.png", width: 80%),
  numbering: none
)

=== 负反馈放大电路放大倍数的一般表达式

$
dot(A) = dot(X)_o / dot(X)_i^'\
dot(F) = dot(X)_f / dot(X)_o\
dot(A)_f = dot(X)_o / dot(X)_i
$

则有

$
dot(A)_f = dot(A) / (1 + dot(A) dot(F))
$
其中$dot(A) dot(F)$称为*环路放大倍数（环路增益）*。环路增益越大，负反馈越深，放大倍数越小。

#figure(
  image("pic/2024-06-03-01-59-24.png", width: 80%),
  numbering: none
)

=== 负反馈放大电路放大倍数和反馈系数的量纲

#figure(
  image("pic/2024-06-03-02-01-05.png", width: 80%),
  numbering: none
)

== 关于负反馈的一些讨论

=== 提高放大倍数的稳定性

在中频段，放大倍数、反馈系数等均为实数。

$
A_f = A / (1 + A F)\
dd(A_f)/dd(A) = 1 / (1 + A F)^2\
dd(A_f) = dd(A) / (1 + A F)^2\
dd(A_f)/A_f = 1/(1 + A F) dd(A)/A
$
说明放大倍数减小到基本放大电路的$1/(1 + A F)$倍；放大倍数的稳定性是基本放大电路的$1 + A F$倍。

=== 改变输入电阻和输出电阻

==== 对输入电阻的影响

对输入电阻的影响仅与反馈网络与基本放大电路输入端的接法有关，即决定于是串联反馈还是并联反馈。

- *引入串联负反馈时*
$
R_i = U_i^' / I_i\
R_(i f) = U_i / I_i = (U_i^' + U_f) / I_i  = (1 + A F) R_i
$
- *引入并联负反馈时*
$
R_i = U_i / I_i\
R_(i f) = U_i / I_i = U_i / (I_i + I_f) = R_i / (1 + A F)
$
*串联负反馈增大输入电阻，并联负反馈减小输入电阻。*

在$(1 + A F) -> ∞$时，引入串联负反馈$R_(i f) -> ∞$，引入并联负反馈$R_(i f) -> 0$。

==== 对输出电阻的影响

对输出电阻的影响仅与反馈网络与基本放大电路输出端的接法有关，即决定于是电压反馈还是电流反馈。

*电压负反馈减小输出电阻，电流负反馈增大输出电阻。*

- *引入电压负反馈时*
$
R_o = U_o / I_o\
R_(o f) = U_o / I_o = U_o / ((U_o - (-A F U_o))/R_o) = R_o / (1 + A F)
$
- *引入电流负反馈时*
$
I_o = U_o / R_o + (- A F I_o)\
R_(o f) = U_o / I_o = (1 + A F) R_o
$

在$(1 + A F) -> ∞$时，引入电压负反馈$R_(o f) -> 0$，引入电流负反馈$R_(o f) -> ∞$。

==== 展宽频带：设反馈网络是纯电阻网络

#figure(
  image("pic/2024-06-03-02-08-44.png", width: 80%),
  numbering: none
)

==== 减小非线性失真

#figure(
  image("pic/2024-06-03-02-09-15.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-06-03-02-09-55.png", width: 80%),
  numbering: none
)

==== 引入负反馈的一般原则

- 稳定Q点应引入直流负反馈，改善动态性能应引入交流负反馈；
- 根据信号源特点，增大输入电阻应引入串联负反馈，减小输入电阻应引入并联负反馈；
- 根据负载需要，需输出稳定电压（即减小输出电阻）的应引入电压负反馈，需输出稳定电流（即增大输出电阻）的应引入电流负反馈；
- 从信号转换关系上看，输出电压是输入电压受控源的为电压串联负反馈，输出电压是输入电流受控源的为电压并联负反馈，输出电流是输入电压受控源的为电流串联负反馈，输出电流是输入电流受控源的为电流并联负反馈；当$(1+A F) >>1$时，它们的转换系数均约为$1/F$。

== 理想运放组成的基本运算电路

=== 概述

==== 运算电路中运放工作在线性区

=== 比例运算电路

==== 反相输入

#figure(
  image("pic/2024-06-04-08-19-09.png", width: 50%),
  numbering: none
)

$
i_N = i_P = 0\
u_P = u_I = 0
$
在节点N处
$
i_F = i_R = u_1/R
$
则有
$
u_O = - i_F R_f = - R_f / R u_1 \
A_u = - R_f / R
$

- 共模输入为0

可以用T形反馈网络实现

#figure(
  image("pic/2024-06-24-16-18-57.png", width: 80%),
  numbering: none,
)

==== 同相输入

#figure(
  image("pic/2024-06-04-08-27-52.png", width: 50%),
  numbering: none
)

电压串联负反馈。

$
u_N = u_P = u_I\
i_F = i_R = 0\
i_R_f = i_R = u_1 / R\
$
从而：
$
u_O = i_R(R_f + R) = (1 + R_f / R) u_1\
A_u = 1 + R_f / R
$

- 输入电阻为无穷大。
- $R' = R parallel R_f$
- 共模输入为$u_I$，这就要求共模抑制比$K_"CMR"$足够大。

同相输入比例运算电路的特例：*电压跟随器*

#figure(
  image("pic/2024-06-04-08-34-45.png", width: 80%),
  numbering: none
)

=== 加减运算电路

==== 反相求和

#figure(
  image("pic/2024-06-04-08-35-30.png", width: 50%),
  numbering: none
)

$
u_O = - R_f / R_1 u_1 - R_f / R_2 u_2 - R_f / R_3 u_3\
$


==== 同相求和

#figure(
  image("pic/2024-06-04-09-10-04.png", width: 80%),
  numbering: none
)

==== 加减运算

#figure(
  image("pic/2024-06-04-09-13-12.png", width: 80%),
  numbering: none
)

电压并联&串联负反馈。

- 共模：$(u_(I 1) + u_(I 2))/2$

由于负反馈之后的输出电阻极小，可以等价于电压源，这时候可以直接进行级联。

== D-A转换器

#figure(
  image("pic/2024-06-25-14-26-57.png", width: 80%),
  numbering: none,
)

=== 权电阻网络DAC

#figure(
  image("pic/2024-06-25-14-27-52.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-14-29-22.png", width: 80%),
  numbering: none,
)

=== 倒T型电阻网络DAC

#figure(
  image("pic/2024-06-25-14-30-04.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-14-30-38.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-14-31-57.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-14-36-30.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-14-38-45.png", width: 80%),
  numbering: none,
)

=== 具有双极性输出的DAC

#figure(
  image("pic/2024-06-25-14-39-45.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-14-50-20.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-14-51-16.png", width: 80%),
  numbering: none,
)

=== DAC的转换精度与速度

#figure(
  image("pic/2024-06-25-14-52-27.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-14-52-53.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-14-53-18.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-14-54-04.png", width: 80%),
  numbering: none,
)

#pagebreak()

= 信号的运算和处理

== 集成运放组成的运算电路

=== 对数运算电路和指数运算电路
   
==== 对数运算

#figure(
  image("pic/2024-06-06-08-14-25.png", width: 80%),
  numbering: none
)

如果想对$-I_s$进行对数运算，可以将管子换成NPN型或者跟一个方向的跟随器。

==== 指数运算

#figure(
  image("pic/2024-06-06-08-15-39.png", width: 80%),
  numbering: none
)

==== 乘法、除法运算电路

#figure(
  image("pic/2024-06-06-08-23-01.png", width: 80%),
  numbering: none
)

=== 实现逆运算的方法

#figure(
  image("pic/2024-06-25-16-38-02.png", width: 80%),
  numbering: none,
)

== 理想运放组成的电压比较器

=== 概述


1. 电压比较器的功能：比较电压的大小。
输入电压是模拟信号；输出电压表示比较的结果，只有高电平和低电平两种情况，为二值信号。使输出产生跃变的输入电压称为阈值电压。广泛用于各种报警电路。

2. 电压比较器的描述方法 :电压传输特性 $u_O = f(u_I)$

*电压传输特性的三个要素：*
- 输出高电平$U_"OH"$和输出低电平$U_"OL"$
- 阈值电压$U_T$
- 输入电压过阈值电压时输出电压跃变的方向

3. 几种常用的电压比较器
- 单限比较器：只有一个阈值电压
- 滞回比较器：具有滞回特性。输入电压的变化方向不同，阈值电压也不同，但输入电压单调变化使输出电压只跃变一次。
- 窗口比较器：有两个阈值电压，输入电压单调变化时输出电压跃变两次。

#figure(
  image("pic/2024-06-06-08-33-35.png", width: 80%),
  numbering: none
)

4. 电压比较器中集成运放工作在非线性区
#figure(
  image("pic/2024-06-06-08-34-26.png", width: 80%),
  numbering: none
)

=== 单限比较器

==== 过零比较器

#figure(
  image("pic/2024-06-06-08-36-44.png", width: 80%),
  numbering: none
)

二极管：限幅，防止烧坏晶体管。稳压管——反向击穿电压稳定。

==== 一般单限比较器

#figure(
  image("pic/2024-06-06-08-38-28.png", width: 80%),
  numbering: none
)

将$U_"REF"$接到上面是为了不引入共模输入。

=== 滞回比较器

#figure(
  image("pic/2024-06-06-08-41-34.png", width: 80%),
  numbering: none
)

#figure(
  image("pic/2024-06-06-08-43-20.png", width: 80%),
  numbering: none
)

1. 若要电压传输特性曲线左右移动，将接地改成$U_"REF"$
   #figure(
     image("pic/2024-06-06-08-50-37.png", width: 80%),
      numbering: none
   )
2. 若要电压传输特性曲线上下移动，加稳压管
3. 若要改变输入电压过阈值电压时输出电压的跃变方向
    #figure(
      image("pic/2024-06-06-08-50-54.png", width: 80%),
      numbering: none
    )

=== 窗口比较器

#figure(
  image("pic/2024-06-06-08-51-45.png", width: 80%),
  numbering: none
)

== A/D转换器

=== A/D转换器的基本原理

1. 采样定理

2. 量化与编码

- 量化：将取样电压表示为最小数量单位（Δ）的整数倍
- 编码：将量化的结果用代码表示出来（二进制，二-十进制）
- 量化误差：当采样电压不能被Δ整除时，将引入量化误差

#figure(
  image("pic/2024-06-25-15-37-04.png", width: 80%),
  numbering: none,
)

=== 直接ADC

#figure(
  image("pic/2024-06-25-15-38-36.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-15-42-07.png", width: 80%),
  numbering: none,
)

- 快，CP触发信号到达到输出稳定建立只需几十ns
- 精度，受参考电压、分压网络等因素影响
- 有存储器，可以没有S/H电路
- 电路规模，n位需要2n-1比较器，触发器

=== 采样保持电路（S/H电路 Sample-Hold）

#figure(
  image("pic/2024-06-25-15-46-45.png", width: 80%),
  numbering: none,
)

=== 反馈比较型ADC

==== 计数型

基本原理：取一个“D”加到DAC上，得到模拟输出电压，将该值与输入电压比较，如两者不等，则调整D的大小，到相等为止，则D为所求值。

#figure(
  image("pic/2024-06-25-15-51-43.png", width: 80%),
  numbering: none,
)


==== 逐次逼近型

#figure(
  image("pic/2024-06-25-15-53-19.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-15-53-56.png", width: 80%),
  numbering: none,
)

=== 间接ADC

==== 双积分型（V-T变换型）

先V转换成与之成正比的时间宽度信号，然后在这个时间内用固定频率脉冲计数

#figure(
  image("pic/2024-06-25-16-09-52.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-16-10-23.png", width: 80%),
  numbering: none,
)


#figure(
  image("pic/2024-06-25-16-10-43.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-16-11-11.png", width: 80%),
  numbering: none,
)

==== V-F变换型



#figure(
  image("pic/2024-06-25-16-11-29.png", width: 80%),
  numbering: none,
)

=== ADC的速度与精度

一、速度：取决于电路结构类型
- 并联比较型：$<1$uS
- 逐次逼近型：几~100uS/次
- 双积分型：几十mS/次
二、转换精度：
- 分辨率 — 位数
- 转换误差 — 实际电路

== 模拟乘法器及其在运算电路中的应用

=== 模拟乘法器的基本原理

#figure(
  image("pic/2024-06-25-16-30-56.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-16-31-57.png", width: 80%),
  numbering: none,
)

=== 在运算电路中的基本应用

#figure(
  image("pic/2024-06-25-16-33-19.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-16-36-44.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-16-42-47.png", width: 80%),
  numbering: none,
)

== 有源滤波电路

运算电路与有源滤波器的比较
- 相同之处
 - 电路中均引入深度负反馈，因而集成运放均工作在线性区。
 - 均具有“虚短”和“虚断”的特点，均可用节点电流法求解电路。
- 不同之处
  - 运算电路研究的是时域问题，有源滤波电路研究的是频域问题；测试时，前者是在输入信号频率不变或直流信号下测量输出电压与输入电压有效值或幅值的关系，后者是在输入电压幅值不变的情况下测量输出电压幅值与输入电压频率的关系。
  - 运算电路用运算关系式描述输出电压与输入电压的关系，有源滤波器用电压放大倍数的幅频特性描述滤波特性。
  
=== 概述

#figure(
  image("pic/2024-06-25-16-50-00.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-16-50-30.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-16-50-49.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-16-58-02.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-16-59-50.png", width: 80%),
  numbering: none,
)

=== 低通滤波器

==== 一阶低通滤波器

#figure(
  image("pic/2024-06-25-17-09-27.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-17-46-41.png", width: 80%),
  numbering: none,
)

==== 二阶低通滤波器

#figure(
  image("pic/2024-06-25-17-53-18.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-17-52-03.png", width: 80%),
  numbering: none,
)

#figure(
  image("pic/2024-06-25-17-53-58.png", width: 80%),
  numbering: none,
)

=== 高通、带通、带阻有源滤波器

#figure(
  image("pic/2024-06-25-17-54-31.png", width: 80%),
  numbering: none,
)